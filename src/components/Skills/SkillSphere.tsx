
//     // Spheres Data
//     const radii = [
//       1,
//       0.6,
//       0.8,
//       0.4,
//       0.9,
//       0.7,
//       0.9,
//       0.3,
//       0.2,
//       0.5,
//       0.6,
//       0.4,
//       0.5,
//       0.6,
//       0.7,
//       0.3,
//       0.4,
//       0.8,
//       0.7,
//       0.5,
//       0.4,
//       0.6,
//       0.35,
//       0.38,
//       0.9,
    
//       0.3,
//       0.6,
//       0.4,
//       0.2,
//       0.35,
//       0.5,
//       0.15,
//       0.2,
//       0.25,
//       0.4,
//       0.8,
//       0.76,
//       0.8,
//       1,
//       0.8,
//       0.7,
//       0.8,
//       0.3,
//       0.5,
//       0.6,
//       0.55,
//       0.42,
//       0.75,
//       0.66,
//       0.6,
//       0.7,
//       0.5,
//       0.6,
//       0.35,
//       0.35,
//       0.35,
//       0.8,
//       0.6,
//       0.7,
//       0.8,
//       0.4,
//       0.89,
//       0.3,
    
//       0.3,
//       0.6,
//       0.4,
//       0.2,
//       0.52,
//       0.5,
//       0.15,
//       0.2,
//       0.25,
//       0.4,
//       0.8,
//       0.76,
//       0.8,
//       1,
//       0.8,
//       0.7,
//       0.8,
//       0.3,
//       0.5,
//       0.6,
//       0.8,
//       0.7,
//       0.75,
//       0.66,
//       0.6,
//       0.7,
//       0.5,
//       0.6,
//       0.35,
//       0.35,
//       0.35,
//       0.8,
//       0.6,
//       0.7,
//       0.8,
//       0.4,
//       0.89,
//       0.3
//     ];
//     const positions = [
//       { x: 0, y: 0, z: 0 },
//       { x: 1.2, y: 0.9, z: -0.5 },
//       { x: 1.8, y: -0.3, z: 0 },
//       { x: -1, y: -1, z: 0 },
//       { x: -1, y: 1.62, z: 0 },
//       { x: -1.65, y: 0, z: -0.4 },
//       { x: -2.13, y: -1.54, z: -0.4 },
//       { x: 0.8, y: 0.94, z: 0.3 },
//       { x: 0.5, y: -1, z: 1.2 },
//       { x: -0.16, y: -1.2, z: 0.9 },
//       { x: 1.5, y: 1.2, z: 0.8 },
//       { x: 0.5, y: -1.58, z: 1.4 },
//       { x: -1.5, y: 1, z: 1.15 },
//       { x: -1.5, y: -1.5, z: 0.99 },
//       { x: -1.5, y: -1.5, z: -1.9 },
//       { x: 1.85, y: 0.8, z: 0.05 },
//       { x: 1.5, y: -1.2, z: -0.75 },
//       { x: 0.9, y: -1.62, z: 0.22 },
//       { x: 0.45, y: 2, z: 0.65 },
//       { x: 2.5, y: 1.22, z: -0.2 },
//       { x: 2.35, y: 0.7, z: 0.55 },
//       { x: -1.8, y: -0.35, z: 0.85 },
//       { x: -1.02, y: 0.2, z: 0.9 },
//       { x: 0.2, y: 1, z: 1 },
//       { x: -2.88, y: 0.7, z: 1 },
    
//       { x: -2, y: -0.95, z: 1.5 },
//       { x: -2.3, y: 2.4, z: -0.1 },
//       { x: -2.5, y: 1.9, z: 1.2 },
//       { x: -1.8, y: 0.37, z: 1.2 },
//       { x: -2.4, y: 1.42, z: 0.05 },
//       { x: -2.72, y: -0.9, z: 1.1 },
//       { x: -1.8, y: -1.34, z: 1.67 },
//       { x: -1.6, y: 1.66, z: 0.91 },
//       { x: -2.8, y: 1.58, z: 1.69 },
//       { x: -2.97, y: 2.3, z: 0.65 },
//       { x: 1.1, y: -0.2, z: -1.45 },
//       { x: -4, y: 1.78, z: 0.38 },
//       { x: 0.12, y: 1.4, z: -1.29 },
//       { x: -1.64, y: 1.4, z: -1.79 },
//       { x: -3.5, y: -0.58, z: 0.1 },
//       { x: -0.1, y: -1, z: -2 },
//       { x: -4.5, y: 0.55, z: -0.5 },
//       { x: -3.87, y: 0, z: 1 },
//       { x: -4.6, y: -0.1, z: 0.65 },
//       { x: -3, y: 1.5, z: -0.7 },
//       { x: -0.5, y: 0.2, z: -1.5 },
//       { x: -1.3, y: -0.45, z: -1.5 },
//       { x: -3.35, y: 0.25, z: -1.5 },
//       { x: -4.76, y: -1.26, z: 0.4 },
//       { x: -4.32, y: 0.85, z: 1.4 },
//       { x: -3.5, y: -1.82, z: 0.9 },
//       { x: -3.6, y: -0.6, z: 1.46 },
//       { x: -4.55, y: -1.5, z: 1.63 },
//       { x: -3.8, y: -1.15, z: 2.1 },
//       { x: -2.9, y: -0.25, z: 1.86 },
//       { x: -2.2, y: -0.4, z: 1.86 },
//       { x: -5.1, y: -0.24, z: 1.86 },
//       { x: -5.27, y: 1.24, z: 0.76 },
//       { x: -5.27, y: 2, z: -0.4 },
//       { x: -6.4, y: 0.4, z: 1 },
//       { x: -5.15, y: 0.95, z: 2 },
//       { x: -6.2, y: 0.5, z: -0.8 },
//       { x: -4, y: 0.08, z: 1.8 },
    
//       { x: 2, y: -0.95, z: 1.5 },
//       { x: 2.3, y: 2.4, z: -0.1 },
//       { x: 2.5, y: 1.9, z: 1.2 },
//       { x: 1.8, y: 0.37, z: 1.2 },
//       { x: 3.24, y: 0.6, z: 1.05 },
//       { x: 2.72, y: -0.9, z: 1.1 },
//       { x: 1.8, y: -1.34, z: 1.67 },
//       { x: 1.6, y: 1.99, z: 0.91 },
//       { x: 2.8, y: 1.58, z: 1.69 },
//       { x: 2.97, y: 2.3, z: 0.65 },
//       { x: -1.3, y: -0.2, z: -2.5 },
//       { x: 4, y: 1.78, z: 0.38 },
//       { x: 1.72, y: 1.4, z: -1.29 },
//       { x: 2.5, y: -1.2, z: -2 },
//       { x: 3.5, y: -0.58, z: 0.1 },
//       { x: 0.1, y: 0.4, z: -2.42 },
//       { x: 4.5, y: 0.55, z: -0.5 },
//       { x: 3.87, y: 0, z: 1 },
//       { x: 4.6, y: -0.1, z: 0.65 },
//       { x: 3, y: 1.5, z: -0.7 },
//       { x: 2.3, y: 0.6, z: -2.6 },
//       { x: 4, y: 1.5, z: -1.6 },
//       { x: 3.35, y: 0.25, z: -1.5 },
//       { x: 4.76, y: -1.26, z: 0.4 },
//       { x: 4.32, y: 0.85, z: 1.4 },
//       { x: 3.5, y: -1.82, z: 0.9 },
//       { x: 3.6, y: -0.6, z: 1.46 },
//       { x: 4.55, y: -1.5, z: 1.63 },
//       { x: 3.8, y: -1.15, z: 2.1 },
//       { x: 2.9, y: -0.25, z: 1.86 },
//       { x: 2.2, y: -0.4, z: 1.86 },
//       { x: 5.1, y: -0.24, z: 1.86 },
//       { x: 5.27, y: 1.24, z: 0.76 },
//       { x: 5.27, y: 2, z: -0.4 },
//       { x: 6.4, y: 0.4, z: 1 },
//       { x: 5.15, y: 0.95, z: 2 },
//       { x: 6.2, y: 0.5, z: -0.8 },
//       { x: 4, y: 0.08, z: 1.8 }
//     ];
    
'use client';
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const SkillSphere = () => {
  const canvasRef = useRef(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const spheresRef = useRef<THREE.Mesh<THREE.SphereGeometry, THREE.MeshLambertMaterial>[]>([]);
  const mouseRef = useRef(new THREE.Vector2());
  const forcesRef = useRef(new Map());
  const animationFrameRef = useRef<number | undefined>(undefined);
  const cameraRef = useRef<THREE.PerspectiveCamera | undefined>(undefined);
  const controlsRef = useRef<OrbitControls | null>(null);

  useEffect(() => {
    if (!canvasRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    sceneRef.current = scene;
    
    const camera = new THREE.PerspectiveCamera(
      25,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 24;
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({
      canvas: canvasRef.current,
      antialias: true,
      alpha: true
    });
    // renderer.setSize(window.innerWidth, window.innerHeight);
    // renderer.setPixelRatio(window.devicePixelRatio);
    // renderer.shadowMap.enabled = true;
    // renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Adds smooth damping effect
    controls.dampingFactor = 0.05;
    controls.minDistance = 10; // Minimum zoom distance
    controls.maxDistance = 50; // Maximum zoom distance
    controls.enablePan = false; // Disable panning
    controls.enableZoom = false; 
    controlsRef.current = controls;

    // Create spheres group
    const group = new THREE.Group();
    const material = new THREE.MeshPhongMaterial({
      color: "#ff7b7b",
      emissive: "#450000",
      emissiveIntensity: 0.3,
      shininess: 40,
      specular: new THREE.Color("#ffffff")
    });

    // Generate sphere positions and radii
    const positions = Array(60).fill(0).map(() => ({
      x: (Math.random() - 0.5) * 10,
      y: (Math.random() - 0.5) * 10,
      z: (Math.random() - 0.5) * 10
    }));
    
    const radii = Array(50).fill(0).map(() => 0.3 + Math.random() * 0.7);

    // Create spheres
    positions.forEach((pos, index) => {
      const radius = radii[index];
      const geometry = new THREE.SphereGeometry(radius, 64, 64);
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(pos.x, -25, pos.z); // Start below viewport
      sphere.userData = { 
        originalPosition: { ...pos }, 
        radius,
        initialDelay: index * 50 // Stagger the initial animation
      };
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      spheresRef.current.push(sphere);
      group.add(sphere);
    });

    scene.add(group);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // Main spotlight for dramatic shadows
    const spotLight = new THREE.SpotLight(0xffffff, 4);
    spotLight.position.set(14, 24, 30);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.5;
    spotLight.decay = 1;
    spotLight.distance = 80;
    spotLight.castShadow = true;
    spotLight.shadow.bias = -0.0001;
    spotLight.shadow.mapSize.width = 2048;
    spotLight.shadow.mapSize.height = 2048;
    scene.add(spotLight);

    // Fill light from the opposite side
    const fillLight = new THREE.DirectionalLight(0xffa07a, 0.3);
    fillLight.position.set(-10, 5, -10);
    scene.add(fillLight);

    // Rim light for depth
    const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
    rimLight.position.set(0, -4, -10);
    scene.add(rimLight);

    // Rest of your animation code remains the same
    const breathingAmplitude = 0.1;
    const breathingSpeed = 0.002;
    let startTime = Date.now();
    const animationDuration = 2000;


    // Animation loop
    const animate = () => {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      
      spheresRef.current.forEach((sphere) => {
        // Initial rising animation
        const delayedTime = elapsedTime - sphere.userData.initialDelay;
        if (delayedTime < animationDuration) {
          const progress = Math.min(delayedTime / animationDuration, 1);
          const easeProgress = 1 - Math.pow(1 - progress, 3); 
          
          sphere.position.y = -25 + (sphere.userData.originalPosition.y + 25) * easeProgress;
        } else {
          // Breathing animation
          const time = currentTime * breathingSpeed;
          const offset = spheresRef.current.indexOf(sphere) * 0.2;
          const breathingY = Math.sin(time + offset) * breathingAmplitude;
          const breathingZ = Math.cos(time + offset) * breathingAmplitude * 0.5;
          
          const force = forcesRef.current.get(sphere.uuid);
          if (force) {
            sphere.position.add(force);
            force.multiplyScalar(0.95);
            
            if (force.length() < 0.01) {
              forcesRef.current.delete(sphere.uuid);
            }
          }
          
          const originalPos = sphere.userData.originalPosition;
          const targetPos = new THREE.Vector3(
            originalPos.x,
            originalPos.y + breathingY,
            originalPos.z + breathingZ
          );
          sphere.position.lerp(targetPos, 0.018);
        }
      });
      
      // Gentle camera rotation
      // camera.position.x = Math.sin(currentTime * 0.0001) * 2;
      // camera.position.z = 24 + Math.cos(currentTime * 0.0001) * 2;
      // camera.lookAt(scene.position);
      controls.update();

      renderer.render(scene, camera);
      animationFrameRef.current = requestAnimationFrame(animate);
    };

    // Mouse interaction
    const raycaster = new THREE.Raycaster();
    
    const handleMouseMove =(event: MouseEvent) => {
      mouseRef.current.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouseRef.current.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouseRef.current, camera);
      const intersects = raycaster.intersectObjects(spheresRef.current);

      if (intersects.length > 0) {
        const hoveredSphere = intersects[0].object;
        const force = new THREE.Vector3();
        force
          .subVectors(intersects[0].point, hoveredSphere.position)
          .normalize()
          .multiplyScalar(0.2);
        forcesRef.current.set(hoveredSphere.uuid, force);
      }
    };

    // Handle window resize
    // const handleResize = () => {
    //   camera.aspect = window.innerWidth / window.innerHeight;
    //   camera.updateProjectionMatrix();
    //   renderer.setSize(window.innerWidth, window.innerHeight);
    // };

    window.addEventListener('mousemove', handleMouseMove);
    // window.addEventListener('resize', handleResize);
    animate();

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      // window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationFrameRef.current);
      controls.dispose();
      renderer.dispose();
    };
  }, []);

return (
  <div className="relative w-full h-screen">
    <canvas ref={canvasRef} className="w-full h-full" />
    <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center gap-8">
      <h1 className="text-4xl text-white font-bold syne">
        Skills
      </h1>
      <div className="flex gap-6 syne-r">
        <button className="flex items-center gap-2 px-6 py-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-all">
          <img src="img/VR.png" alt="XR" className="w-6 h-6" />
          <span className="text-white">XR</span>
        </button>
        <button className="flex items-center gap-2 px-6 py-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-all">
          <img src="img/Code.png" alt="Code" className="w-6 h-6" />
          <span className="text-white">Code</span>
        </button>
        <button className="flex items-center gap-2 px-6 py-3 bg-white/10 backdrop-blur-sm rounded-lg hover:bg-white/20 transition-all">
          <img src="img/Design.png" alt="Design" className="w-6 h-6" />
          <span className="text-white">Design</span>
        </button>
      </div>
    </div>
  </div>
);
};

export default SkillSphere;